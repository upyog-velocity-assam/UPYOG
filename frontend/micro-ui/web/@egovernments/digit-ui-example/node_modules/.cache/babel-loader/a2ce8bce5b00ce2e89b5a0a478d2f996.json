{"ast":null,"code":"(function (global, factory) {\n  typeof exports === 'object' && typeof module !== 'undefined' ? factory(exports) : typeof define === 'function' && define.amd ? define(['exports'], factory) : (global = typeof globalThis !== 'undefined' ? globalThis : global || self, factory(global[\"fast-equals\"] = {}));\n})(this, function (exports) {\n  'use strict';\n\n  var getOwnPropertyNames = Object.getOwnPropertyNames,\n    getOwnPropertySymbols = Object.getOwnPropertySymbols;\n  var hasOwnProperty = Object.prototype.hasOwnProperty;\n  /**\n   * Combine two comparators into a single comparators.\n   */\n  function combineComparators(comparatorA, comparatorB) {\n    return function isEqual(a, b, state) {\n      return comparatorA(a, b, state) && comparatorB(a, b, state);\n    };\n  }\n  /**\n   * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n   * for circular references to be safely included in the comparison without creating\n   * stack overflows.\n   */\n  function createIsCircular(areItemsEqual) {\n    return function isCircular(a, b, state) {\n      if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n        return areItemsEqual(a, b, state);\n      }\n      var cache = state.cache;\n      var cachedA = cache.get(a);\n      var cachedB = cache.get(b);\n      if (cachedA && cachedB) {\n        return cachedA === b && cachedB === a;\n      }\n      cache.set(a, b);\n      cache.set(b, a);\n      var result = areItemsEqual(a, b, state);\n      cache.delete(a);\n      cache.delete(b);\n      return result;\n    };\n  }\n  /**\n   * Get the properties to strictly examine, which include both own properties that are\n   * not enumerable and symbol properties.\n   */\n  function getStrictProperties(object) {\n    return getOwnPropertyNames(object).concat(getOwnPropertySymbols(object));\n  }\n  /**\n   * Whether the object contains the property passed as an own property.\n   */\n  var hasOwn = Object.hasOwn || function (object, property) {\n    return hasOwnProperty.call(object, property);\n  };\n  /**\n   * Whether the values passed are strictly equal or both NaN.\n   */\n  function sameValueZeroEqual(a, b) {\n    return a || b ? a === b : a === b || a !== a && b !== b;\n  }\n  var OWNER = '_owner';\n  var getOwnPropertyDescriptor = Object.getOwnPropertyDescriptor,\n    keys = Object.keys;\n  /**\n   * Whether the arrays are equal in value.\n   */\n  function areArraysEqual(a, b, state) {\n    var index = a.length;\n    if (b.length !== index) {\n      return false;\n    }\n    while (index-- > 0) {\n      if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Whether the dates passed are equal in value.\n   */\n  function areDatesEqual(a, b) {\n    return sameValueZeroEqual(a.getTime(), b.getTime());\n  }\n  /**\n   * Whether the `Map`s are equal in value.\n   */\n  function areMapsEqual(a, b, state) {\n    if (a.size !== b.size) {\n      return false;\n    }\n    var matchedIndices = {};\n    var aIterable = a.entries();\n    var index = 0;\n    var aResult;\n    var bResult;\n    while (aResult = aIterable.next()) {\n      if (aResult.done) {\n        break;\n      }\n      var bIterable = b.entries();\n      var hasMatch = false;\n      var matchIndex = 0;\n      while (bResult = bIterable.next()) {\n        if (bResult.done) {\n          break;\n        }\n        var _a = aResult.value,\n          aKey = _a[0],\n          aValue = _a[1];\n        var _b = bResult.value,\n          bKey = _b[0],\n          bValue = _b[1];\n        if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aKey, bKey, index, matchIndex, a, b, state) && state.equals(aValue, bValue, aKey, bKey, a, b, state))) {\n          matchedIndices[matchIndex] = true;\n        }\n        matchIndex++;\n      }\n      if (!hasMatch) {\n        return false;\n      }\n      index++;\n    }\n    return true;\n  }\n  /**\n   * Whether the objects are equal in value.\n   */\n  function areObjectsEqual(a, b, state) {\n    var properties = keys(a);\n    var index = properties.length;\n    if (keys(b).length !== index) {\n      return false;\n    }\n    var property;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while (index-- > 0) {\n      property = properties[index];\n      if (property === OWNER && (a.$$typeof || b.$$typeof) && a.$$typeof !== b.$$typeof) {\n        return false;\n      }\n      if (!hasOwn(b, property) || !state.equals(a[property], b[property], property, property, a, b, state)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Whether the objects are equal in value with strict property checking.\n   */\n  function areObjectsEqualStrict(a, b, state) {\n    var properties = getStrictProperties(a);\n    var index = properties.length;\n    if (getStrictProperties(b).length !== index) {\n      return false;\n    }\n    var property;\n    var descriptorA;\n    var descriptorB;\n    // Decrementing `while` showed faster results than either incrementing or\n    // decrementing `for` loop and than an incrementing `while` loop. Declarative\n    // methods like `some` / `every` were not used to avoid incurring the garbage\n    // cost of anonymous callbacks.\n    while (index-- > 0) {\n      property = properties[index];\n      if (property === OWNER && (a.$$typeof || b.$$typeof) && a.$$typeof !== b.$$typeof) {\n        return false;\n      }\n      if (!hasOwn(b, property)) {\n        return false;\n      }\n      if (!state.equals(a[property], b[property], property, property, a, b, state)) {\n        return false;\n      }\n      descriptorA = getOwnPropertyDescriptor(a, property);\n      descriptorB = getOwnPropertyDescriptor(b, property);\n      if ((descriptorA || descriptorB) && (!descriptorA || !descriptorB || descriptorA.configurable !== descriptorB.configurable || descriptorA.enumerable !== descriptorB.enumerable || descriptorA.writable !== descriptorB.writable)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Whether the primitive wrappers passed are equal in value.\n   */\n  function arePrimitiveWrappersEqual(a, b) {\n    return sameValueZeroEqual(a.valueOf(), b.valueOf());\n  }\n  /**\n   * Whether the regexps passed are equal in value.\n   */\n  function areRegExpsEqual(a, b) {\n    return a.source === b.source && a.flags === b.flags;\n  }\n  /**\n   * Whether the `Set`s are equal in value.\n   */\n  function areSetsEqual(a, b, state) {\n    if (a.size !== b.size) {\n      return false;\n    }\n    var matchedIndices = {};\n    var aIterable = a.values();\n    var aResult;\n    var bResult;\n    while (aResult = aIterable.next()) {\n      if (aResult.done) {\n        break;\n      }\n      var bIterable = b.values();\n      var hasMatch = false;\n      var matchIndex = 0;\n      while (bResult = bIterable.next()) {\n        if (bResult.done) {\n          break;\n        }\n        if (!hasMatch && !matchedIndices[matchIndex] && (hasMatch = state.equals(aResult.value, bResult.value, aResult.value, bResult.value, a, b, state))) {\n          matchedIndices[matchIndex] = true;\n        }\n        matchIndex++;\n      }\n      if (!hasMatch) {\n        return false;\n      }\n    }\n    return true;\n  }\n  /**\n   * Whether the TypedArray instances are equal in value.\n   */\n  function areTypedArraysEqual(a, b) {\n    var index = a.length;\n    if (b.length !== index) {\n      return false;\n    }\n    while (index-- > 0) {\n      if (a[index] !== b[index]) {\n        return false;\n      }\n    }\n    return true;\n  }\n  var ARGUMENTS_TAG = '[object Arguments]';\n  var BOOLEAN_TAG = '[object Boolean]';\n  var DATE_TAG = '[object Date]';\n  var MAP_TAG = '[object Map]';\n  var NUMBER_TAG = '[object Number]';\n  var OBJECT_TAG = '[object Object]';\n  var REG_EXP_TAG = '[object RegExp]';\n  var SET_TAG = '[object Set]';\n  var STRING_TAG = '[object String]';\n  var isArray = Array.isArray;\n  var isTypedArray = typeof ArrayBuffer === 'function' && ArrayBuffer.isView ? ArrayBuffer.isView : null;\n  var assign = Object.assign;\n  var getTag = Object.prototype.toString.call.bind(Object.prototype.toString);\n  /**\n   * Create a comparator method based on the type-specific equality comparators passed.\n   */\n  function createEqualityComparator(_a) {\n    var areArraysEqual = _a.areArraysEqual,\n      areDatesEqual = _a.areDatesEqual,\n      areMapsEqual = _a.areMapsEqual,\n      areObjectsEqual = _a.areObjectsEqual,\n      arePrimitiveWrappersEqual = _a.arePrimitiveWrappersEqual,\n      areRegExpsEqual = _a.areRegExpsEqual,\n      areSetsEqual = _a.areSetsEqual,\n      areTypedArraysEqual = _a.areTypedArraysEqual;\n    /**\n     * compare the value of the two objects and return true if they are equivalent in values\n     */\n    return function comparator(a, b, state) {\n      // If the items are strictly equal, no need to do a value comparison.\n      if (a === b) {\n        return true;\n      }\n      // If the items are not non-nullish objects, then the only possibility\n      // of them being equal but not strictly is if they are both `NaN`. Since\n      // `NaN` is uniquely not equal to itself, we can use self-comparison of\n      // both objects, which is faster than `isNaN()`.\n      if (a == null || b == null || typeof a !== 'object' || typeof b !== 'object') {\n        return a !== a && b !== b;\n      }\n      var constructor = a.constructor;\n      // Checks are listed in order of commonality of use-case:\n      //   1. Common complex object types (plain object, array)\n      //   2. Common data values (date, regexp)\n      //   3. Less-common complex object types (map, set)\n      //   4. Less-common data values (promise, primitive wrappers)\n      // Inherently this is both subjective and assumptive, however\n      // when reviewing comparable libraries in the wild this order\n      // appears to be generally consistent.\n      // Constructors should match, otherwise there is potential for false positives\n      // between class and subclass or custom object and POJO.\n      if (constructor !== b.constructor) {\n        return false;\n      }\n      // `isPlainObject` only checks against the object's own realm. Cross-realm\n      // comparisons are rare, and will be handled in the ultimate fallback, so\n      // we can avoid capturing the string tag.\n      if (constructor === Object) {\n        return areObjectsEqual(a, b, state);\n      }\n      // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n      // the string tag or doing an `instanceof` check.\n      if (isArray(a)) {\n        return areArraysEqual(a, b, state);\n      }\n      // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n      // capturing the string tag or comparing against all possible constructors.\n      if (isTypedArray != null && isTypedArray(a)) {\n        return areTypedArraysEqual(a, b, state);\n      }\n      // Try to fast-path equality checks for other complex object types in the\n      // same realm to avoid capturing the string tag. Strict equality is used\n      // instead of `instanceof` because it is more performant for the common\n      // use-case. If someone is subclassing a native class, it will be handled\n      // with the string tag comparison.\n      if (constructor === Date) {\n        return areDatesEqual(a, b, state);\n      }\n      if (constructor === RegExp) {\n        return areRegExpsEqual(a, b, state);\n      }\n      if (constructor === Map) {\n        return areMapsEqual(a, b, state);\n      }\n      if (constructor === Set) {\n        return areSetsEqual(a, b, state);\n      }\n      // Since this is a custom object, capture the string tag to determing its type.\n      // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n      var tag = getTag(a);\n      if (tag === DATE_TAG) {\n        return areDatesEqual(a, b, state);\n      }\n      if (tag === REG_EXP_TAG) {\n        return areRegExpsEqual(a, b, state);\n      }\n      if (tag === MAP_TAG) {\n        return areMapsEqual(a, b, state);\n      }\n      if (tag === SET_TAG) {\n        return areSetsEqual(a, b, state);\n      }\n      if (tag === OBJECT_TAG) {\n        // The exception for value comparison is custom `Promise`-like class instances. These should\n        // be treated the same as standard `Promise` objects, which means strict equality, and if\n        // it reaches this point then that strict equality comparison has already failed.\n        return typeof a.then !== 'function' && typeof b.then !== 'function' && areObjectsEqual(a, b, state);\n      }\n      // If an arguments tag, it should be treated as a standard object.\n      if (tag === ARGUMENTS_TAG) {\n        return areObjectsEqual(a, b, state);\n      }\n      // As the penultimate fallback, check if the values passed are primitive wrappers. This\n      // is very rare in modern JS, which is why it is deprioritized compared to all other object\n      // types.\n      if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n        return arePrimitiveWrappersEqual(a, b, state);\n      }\n      // If not matching any tags that require a specific type of comparison, then we hard-code false because\n      // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n      //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n      //     comparison that can be made.\n      //   - For types that can be introspected, but rarely have requirements to be compared\n      //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n      //     use-cases (may be included in a future release, if requested enough).\n      //   - For types that can be introspected but do not have an objective definition of what\n      //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n      // In all cases, these decisions should be reevaluated based on changes to the language and\n      // common development practices.\n      return false;\n    };\n  }\n  /**\n   * Create the configuration object used for building comparators.\n   */\n  function createEqualityComparatorConfig(_a) {\n    var circular = _a.circular,\n      createCustomConfig = _a.createCustomConfig,\n      strict = _a.strict;\n    var config = {\n      areArraysEqual: strict ? areObjectsEqualStrict : areArraysEqual,\n      areDatesEqual: areDatesEqual,\n      areMapsEqual: strict ? combineComparators(areMapsEqual, areObjectsEqualStrict) : areMapsEqual,\n      areObjectsEqual: strict ? areObjectsEqualStrict : areObjectsEqual,\n      arePrimitiveWrappersEqual: arePrimitiveWrappersEqual,\n      areRegExpsEqual: areRegExpsEqual,\n      areSetsEqual: strict ? combineComparators(areSetsEqual, areObjectsEqualStrict) : areSetsEqual,\n      areTypedArraysEqual: strict ? areObjectsEqualStrict : areTypedArraysEqual\n    };\n    if (createCustomConfig) {\n      config = assign({}, config, createCustomConfig(config));\n    }\n    if (circular) {\n      var areArraysEqual$1 = createIsCircular(config.areArraysEqual);\n      var areMapsEqual$1 = createIsCircular(config.areMapsEqual);\n      var areObjectsEqual$1 = createIsCircular(config.areObjectsEqual);\n      var areSetsEqual$1 = createIsCircular(config.areSetsEqual);\n      config = assign({}, config, {\n        areArraysEqual: areArraysEqual$1,\n        areMapsEqual: areMapsEqual$1,\n        areObjectsEqual: areObjectsEqual$1,\n        areSetsEqual: areSetsEqual$1\n      });\n    }\n    return config;\n  }\n  /**\n   * Default equality comparator pass-through, used as the standard `isEqual` creator for\n   * use inside the built comparator.\n   */\n  function createInternalEqualityComparator(compare) {\n    return function (a, b, _indexOrKeyA, _indexOrKeyB, _parentA, _parentB, state) {\n      return compare(a, b, state);\n    };\n  }\n  /**\n   * Create the `isEqual` function used by the consuming application.\n   */\n  function createIsEqual(_a) {\n    var circular = _a.circular,\n      comparator = _a.comparator,\n      createState = _a.createState,\n      equals = _a.equals,\n      strict = _a.strict;\n    if (createState) {\n      return function isEqual(a, b) {\n        var _a = createState(),\n          _b = _a.cache,\n          cache = _b === void 0 ? circular ? new WeakMap() : undefined : _b,\n          meta = _a.meta;\n        return comparator(a, b, {\n          cache: cache,\n          equals: equals,\n          meta: meta,\n          strict: strict\n        });\n      };\n    }\n    if (circular) {\n      return function isEqual(a, b) {\n        return comparator(a, b, {\n          cache: new WeakMap(),\n          equals: equals,\n          meta: undefined,\n          strict: strict\n        });\n      };\n    }\n    var state = {\n      cache: undefined,\n      equals: equals,\n      meta: undefined,\n      strict: strict\n    };\n    return function isEqual(a, b) {\n      return comparator(a, b, state);\n    };\n  }\n\n  /**\n   * Whether the items passed are deeply-equal in value.\n   */\n  var deepEqual = createCustomEqual();\n  /**\n   * Whether the items passed are deeply-equal in value based on strict comparison.\n   */\n  var strictDeepEqual = createCustomEqual({\n    strict: true\n  });\n  /**\n   * Whether the items passed are deeply-equal in value, including circular references.\n   */\n  var circularDeepEqual = createCustomEqual({\n    circular: true\n  });\n  /**\n   * Whether the items passed are deeply-equal in value, including circular references,\n   * based on strict comparison.\n   */\n  var strictCircularDeepEqual = createCustomEqual({\n    circular: true,\n    strict: true\n  });\n  /**\n   * Whether the items passed are shallowly-equal in value.\n   */\n  var shallowEqual = createCustomEqual({\n    createInternalComparator: function () {\n      return sameValueZeroEqual;\n    }\n  });\n  /**\n   * Whether the items passed are shallowly-equal in value based on strict comparison\n   */\n  var strictShallowEqual = createCustomEqual({\n    strict: true,\n    createInternalComparator: function () {\n      return sameValueZeroEqual;\n    }\n  });\n  /**\n   * Whether the items passed are shallowly-equal in value, including circular references.\n   */\n  var circularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function () {\n      return sameValueZeroEqual;\n    }\n  });\n  /**\n   * Whether the items passed are shallowly-equal in value, including circular references,\n   * based on strict comparison.\n   */\n  var strictCircularShallowEqual = createCustomEqual({\n    circular: true,\n    createInternalComparator: function () {\n      return sameValueZeroEqual;\n    },\n    strict: true\n  });\n  /**\n   * Create a custom equality comparison method.\n   *\n   * This can be done to create very targeted comparisons in extreme hot-path scenarios\n   * where the standard methods are not performant enough, but can also be used to provide\n   * support for legacy environments that do not support expected features like\n   * `RegExp.prototype.flags` out of the box.\n   */\n  function createCustomEqual(options) {\n    if (options === void 0) {\n      options = {};\n    }\n    var _a = options.circular,\n      circular = _a === void 0 ? false : _a,\n      createCustomInternalComparator = options.createInternalComparator,\n      createState = options.createState,\n      _b = options.strict,\n      strict = _b === void 0 ? false : _b;\n    var config = createEqualityComparatorConfig(options);\n    var comparator = createEqualityComparator(config);\n    var equals = createCustomInternalComparator ? createCustomInternalComparator(comparator) : createInternalEqualityComparator(comparator);\n    return createIsEqual({\n      circular: circular,\n      comparator: comparator,\n      createState: createState,\n      equals: equals,\n      strict: strict\n    });\n  }\n  exports.circularDeepEqual = circularDeepEqual;\n  exports.circularShallowEqual = circularShallowEqual;\n  exports.createCustomEqual = createCustomEqual;\n  exports.deepEqual = deepEqual;\n  exports.sameValueZeroEqual = sameValueZeroEqual;\n  exports.shallowEqual = shallowEqual;\n  exports.strictCircularDeepEqual = strictCircularDeepEqual;\n  exports.strictCircularShallowEqual = strictCircularShallowEqual;\n  exports.strictDeepEqual = strictDeepEqual;\n  exports.strictShallowEqual = strictShallowEqual;\n});","map":{"version":3,"sources":["../../src/utils.ts","../../src/equals.ts","../../src/comparator.ts","../../src/index.ts"],"names":["areObjectsEqualStrictDefault","areArraysEqualDefault","areDatesEqualDefault","areMapsEqualDefault","areObjectsEqualDefault","arePrimitiveWrappersEqualDefault","areRegExpsEqualDefault","areSetsEqualDefault","areArraysEqual","areMapsEqual","areObjectsEqual","areSetsEqual"],"mappings":"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","sourcesContent":["import {\n  AnyEqualityComparator,\n  Cache,\n  CircularState,\n  Dictionary,\n  State,\n  TypeEqualityComparator,\n} from './internalTypes';\n\nconst { getOwnPropertyNames, getOwnPropertySymbols } = Object;\nconst { hasOwnProperty } = Object.prototype;\n\n/**\n * Combine two comparators into a single comparators.\n */\nexport function combineComparators<Meta>(\n  comparatorA: AnyEqualityComparator<Meta>,\n  comparatorB: AnyEqualityComparator<Meta>,\n) {\n  return function isEqual<A, B>(a: A, b: B, state: State<Meta>) {\n    return comparatorA(a, b, state) && comparatorB(a, b, state);\n  };\n}\n\n/**\n * Wrap the provided `areItemsEqual` method to manage the circular state, allowing\n * for circular references to be safely included in the comparison without creating\n * stack overflows.\n */\nexport function createIsCircular<\n  AreItemsEqual extends TypeEqualityComparator<any, any>,\n>(areItemsEqual: AreItemsEqual): AreItemsEqual {\n  return function isCircular(\n    a: any,\n    b: any,\n    state: CircularState<Cache<any, any>>,\n  ) {\n    if (!a || !b || typeof a !== 'object' || typeof b !== 'object') {\n      return areItemsEqual(a, b, state);\n    }\n\n    const { cache } = state;\n\n    const cachedA = cache.get(a);\n    const cachedB = cache.get(b);\n\n    if (cachedA && cachedB) {\n      return cachedA === b && cachedB === a;\n    }\n\n    cache.set(a, b);\n    cache.set(b, a);\n\n    const result = areItemsEqual(a, b, state);\n\n    cache.delete(a);\n    cache.delete(b);\n\n    return result;\n  } as AreItemsEqual;\n}\n\n/**\n * Get the properties to strictly examine, which include both own properties that are\n * not enumerable and symbol properties.\n */\nexport function getStrictProperties(\n  object: Dictionary,\n): Array<string | symbol> {\n  return (getOwnPropertyNames(object) as Array<string | symbol>).concat(\n    getOwnPropertySymbols(object),\n  );\n}\n\n/**\n * Whether the object contains the property passed as an own property.\n */\nexport const hasOwn =\n  Object.hasOwn ||\n  ((object: Dictionary, property: number | string | symbol) =>\n    hasOwnProperty.call(object, property));\n\n/**\n * Whether the values passed are strictly equal or both NaN.\n */\nexport function sameValueZeroEqual(a: any, b: any): boolean {\n  return a || b ? a === b : a === b || (a !== a && b !== b);\n}\n","import { getStrictProperties, hasOwn, sameValueZeroEqual } from './utils';\nimport type {\n  Dictionary,\n  PrimitiveWrapper,\n  State,\n  TypedArray,\n} from './internalTypes';\n\nconst OWNER = '_owner';\n\nconst { getOwnPropertyDescriptor, keys } = Object;\n\n/**\n * Whether the arrays are equal in value.\n */\nexport function areArraysEqual(a: any[], b: any[], state: State<any>) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (!state.equals(a[index], b[index], index, index, a, b, state)) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the dates passed are equal in value.\n */\nexport function areDatesEqual(a: Date, b: Date): boolean {\n  return sameValueZeroEqual(a.getTime(), b.getTime());\n}\n\n/**\n * Whether the `Map`s are equal in value.\n */\nexport function areMapsEqual(\n  a: Map<any, any>,\n  b: Map<any, any>,\n  state: State<any>,\n): boolean {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  const matchedIndices: Record<number, true> = {};\n  const aIterable = a.entries();\n\n  let index = 0;\n  let aResult: IteratorResult<[any, any]>;\n  let bResult: IteratorResult<[any, any]>;\n\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.entries();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      const [aKey, aValue] = aResult.value;\n      const [bKey, bValue] = bResult.value;\n\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndex] &&\n        (hasMatch =\n          state.equals(aKey, bKey, index, matchIndex, a, b, state) &&\n          state.equals(aValue, bValue, aKey, bKey, a, b, state))\n      ) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n\n    index++;\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value.\n */\nexport function areObjectsEqual(\n  a: Dictionary,\n  b: Dictionary,\n  state: State<any>,\n): boolean {\n  const properties = keys(a);\n\n  let index = properties.length;\n\n  if (keys(b).length !== index) {\n    return false;\n  }\n\n  let property: string;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    property = properties[index]!;\n\n    if (\n      property === OWNER &&\n      (a.$$typeof || b.$$typeof) &&\n      a.$$typeof !== b.$$typeof\n    ) {\n      return false;\n    }\n\n    if (\n      !hasOwn(b, property) ||\n      !state.equals(a[property], b[property], property, property, a, b, state)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the objects are equal in value with strict property checking.\n */\nexport function areObjectsEqualStrict(\n  a: Dictionary,\n  b: Dictionary,\n  state: State<any>,\n): boolean {\n  const properties = getStrictProperties(a);\n\n  let index = properties.length;\n\n  if (getStrictProperties(b).length !== index) {\n    return false;\n  }\n\n  let property: string | symbol;\n  let descriptorA: ReturnType<typeof getOwnPropertyDescriptor>;\n  let descriptorB: ReturnType<typeof getOwnPropertyDescriptor>;\n\n  // Decrementing `while` showed faster results than either incrementing or\n  // decrementing `for` loop and than an incrementing `while` loop. Declarative\n  // methods like `some` / `every` were not used to avoid incurring the garbage\n  // cost of anonymous callbacks.\n  while (index-- > 0) {\n    property = properties[index]!;\n\n    if (\n      property === OWNER &&\n      (a.$$typeof || b.$$typeof) &&\n      a.$$typeof !== b.$$typeof\n    ) {\n      return false;\n    }\n\n    if (!hasOwn(b, property)) {\n      return false;\n    }\n\n    if (\n      !state.equals(a[property], b[property], property, property, a, b, state)\n    ) {\n      return false;\n    }\n\n    descriptorA = getOwnPropertyDescriptor(a, property);\n    descriptorB = getOwnPropertyDescriptor(b, property);\n\n    if (\n      (descriptorA || descriptorB) &&\n      (!descriptorA ||\n        !descriptorB ||\n        descriptorA.configurable !== descriptorB.configurable ||\n        descriptorA.enumerable !== descriptorB.enumerable ||\n        descriptorA.writable !== descriptorB.writable)\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the primitive wrappers passed are equal in value.\n */\nexport function arePrimitiveWrappersEqual(\n  a: PrimitiveWrapper,\n  b: PrimitiveWrapper,\n): boolean {\n  return sameValueZeroEqual(a.valueOf(), b.valueOf());\n}\n\n/**\n * Whether the regexps passed are equal in value.\n */\nexport function areRegExpsEqual(a: RegExp, b: RegExp): boolean {\n  return a.source === b.source && a.flags === b.flags;\n}\n\n/**\n * Whether the `Set`s are equal in value.\n */\nexport function areSetsEqual(\n  a: Set<any>,\n  b: Set<any>,\n  state: State<any>,\n): boolean {\n  if (a.size !== b.size) {\n    return false;\n  }\n\n  const matchedIndices: Record<number, true> = {};\n  const aIterable = a.values();\n\n  let aResult: IteratorResult<any>;\n  let bResult: IteratorResult<any>;\n\n  while ((aResult = aIterable.next())) {\n    if (aResult.done) {\n      break;\n    }\n\n    const bIterable = b.values();\n\n    let hasMatch = false;\n    let matchIndex = 0;\n\n    while ((bResult = bIterable.next())) {\n      if (bResult.done) {\n        break;\n      }\n\n      if (\n        !hasMatch &&\n        !matchedIndices[matchIndex] &&\n        (hasMatch = state.equals(\n          aResult.value,\n          bResult.value,\n          aResult.value,\n          bResult.value,\n          a,\n          b,\n          state,\n        ))\n      ) {\n        matchedIndices[matchIndex] = true;\n      }\n\n      matchIndex++;\n    }\n\n    if (!hasMatch) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\n/**\n * Whether the TypedArray instances are equal in value.\n */\nexport function areTypedArraysEqual(a: TypedArray, b: TypedArray) {\n  let index = a.length;\n\n  if (b.length !== index) {\n    return false;\n  }\n\n  while (index-- > 0) {\n    if (a[index] !== b[index]) {\n      return false;\n    }\n  }\n\n  return true;\n}\n","import {\n  areArraysEqual as areArraysEqualDefault,\n  areDatesEqual as areDatesEqualDefault,\n  areMapsEqual as areMapsEqualDefault,\n  areObjectsEqual as areObjectsEqualDefault,\n  areObjectsEqualStrict as areObjectsEqualStrictDefault,\n  arePrimitiveWrappersEqual as arePrimitiveWrappersEqualDefault,\n  areRegExpsEqual as areRegExpsEqualDefault,\n  areSetsEqual as areSetsEqualDefault,\n  areTypedArraysEqual,\n} from './equals';\nimport { combineComparators, createIsCircular } from './utils';\nimport type {\n  ComparatorConfig,\n  CreateState,\n  CustomEqualCreatorOptions,\n  EqualityComparator,\n  InternalEqualityComparator,\n  State,\n} from './internalTypes';\n\nconst ARGUMENTS_TAG = '[object Arguments]';\nconst BOOLEAN_TAG = '[object Boolean]';\nconst DATE_TAG = '[object Date]';\nconst MAP_TAG = '[object Map]';\nconst NUMBER_TAG = '[object Number]';\nconst OBJECT_TAG = '[object Object]';\nconst REG_EXP_TAG = '[object RegExp]';\nconst SET_TAG = '[object Set]';\nconst STRING_TAG = '[object String]';\n\nconst { isArray } = Array;\nconst isTypedArray =\n  typeof ArrayBuffer === 'function' && ArrayBuffer.isView\n    ? ArrayBuffer.isView\n    : null;\nconst { assign } = Object;\nconst getTag = Object.prototype.toString.call.bind(\n  Object.prototype.toString,\n) as (a: object) => string;\n\ninterface CreateIsEqualOptions<Meta> {\n  circular: boolean;\n  comparator: EqualityComparator<Meta>;\n  createState: CreateState<Meta> | undefined;\n  equals: InternalEqualityComparator<Meta>;\n  strict: boolean;\n}\n\n/**\n * Create a comparator method based on the type-specific equality comparators passed.\n */\nexport function createEqualityComparator<Meta>({\n  areArraysEqual,\n  areDatesEqual,\n  areMapsEqual,\n  areObjectsEqual,\n  arePrimitiveWrappersEqual,\n  areRegExpsEqual,\n  areSetsEqual,\n  areTypedArraysEqual,\n}: ComparatorConfig<Meta>): EqualityComparator<Meta> {\n  /**\n   * compare the value of the two objects and return true if they are equivalent in values\n   */\n  return function comparator(a: any, b: any, state: State<Meta>): boolean {\n    // If the items are strictly equal, no need to do a value comparison.\n    if (a === b) {\n      return true;\n    }\n\n    // If the items are not non-nullish objects, then the only possibility\n    // of them being equal but not strictly is if they are both `NaN`. Since\n    // `NaN` is uniquely not equal to itself, we can use self-comparison of\n    // both objects, which is faster than `isNaN()`.\n    if (\n      a == null ||\n      b == null ||\n      typeof a !== 'object' ||\n      typeof b !== 'object'\n    ) {\n      return a !== a && b !== b;\n    }\n\n    const constructor = a.constructor;\n\n    // Checks are listed in order of commonality of use-case:\n    //   1. Common complex object types (plain object, array)\n    //   2. Common data values (date, regexp)\n    //   3. Less-common complex object types (map, set)\n    //   4. Less-common data values (promise, primitive wrappers)\n    // Inherently this is both subjective and assumptive, however\n    // when reviewing comparable libraries in the wild this order\n    // appears to be generally consistent.\n\n    // Constructors should match, otherwise there is potential for false positives\n    // between class and subclass or custom object and POJO.\n    if (constructor !== b.constructor) {\n      return false;\n    }\n\n    // `isPlainObject` only checks against the object's own realm. Cross-realm\n    // comparisons are rare, and will be handled in the ultimate fallback, so\n    // we can avoid capturing the string tag.\n    if (constructor === Object) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    // `isArray()` works on subclasses and is cross-realm, so we can avoid capturing\n    // the string tag or doing an `instanceof` check.\n    if (isArray(a)) {\n      return areArraysEqual(a, b, state);\n    }\n\n    // `isTypedArray()` works on all possible TypedArray classes, so we can avoid\n    // capturing the string tag or comparing against all possible constructors.\n    if (isTypedArray != null && isTypedArray(a)) {\n      return areTypedArraysEqual(a, b, state);\n    }\n\n    // Try to fast-path equality checks for other complex object types in the\n    // same realm to avoid capturing the string tag. Strict equality is used\n    // instead of `instanceof` because it is more performant for the common\n    // use-case. If someone is subclassing a native class, it will be handled\n    // with the string tag comparison.\n\n    if (constructor === Date) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (constructor === RegExp) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (constructor === Map) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (constructor === Set) {\n      return areSetsEqual(a, b, state);\n    }\n\n    // Since this is a custom object, capture the string tag to determing its type.\n    // This is reasonably performant in modern environments like v8 and SpiderMonkey.\n    const tag = getTag(a);\n\n    if (tag === DATE_TAG) {\n      return areDatesEqual(a, b, state);\n    }\n\n    if (tag === REG_EXP_TAG) {\n      return areRegExpsEqual(a, b, state);\n    }\n\n    if (tag === MAP_TAG) {\n      return areMapsEqual(a, b, state);\n    }\n\n    if (tag === SET_TAG) {\n      return areSetsEqual(a, b, state);\n    }\n\n    if (tag === OBJECT_TAG) {\n      // The exception for value comparison is custom `Promise`-like class instances. These should\n      // be treated the same as standard `Promise` objects, which means strict equality, and if\n      // it reaches this point then that strict equality comparison has already failed.\n      return (\n        typeof a.then !== 'function' &&\n        typeof b.then !== 'function' &&\n        areObjectsEqual(a, b, state)\n      );\n    }\n\n    // If an arguments tag, it should be treated as a standard object.\n    if (tag === ARGUMENTS_TAG) {\n      return areObjectsEqual(a, b, state);\n    }\n\n    // As the penultimate fallback, check if the values passed are primitive wrappers. This\n    // is very rare in modern JS, which is why it is deprioritized compared to all other object\n    // types.\n    if (tag === BOOLEAN_TAG || tag === NUMBER_TAG || tag === STRING_TAG) {\n      return arePrimitiveWrappersEqual(a, b, state);\n    }\n\n    // If not matching any tags that require a specific type of comparison, then we hard-code false because\n    // the only thing remaining is strict equality, which has already been compared. This is for a few reasons:\n    //   - Certain types that cannot be introspected (e.g., `WeakMap`). For these types, this is the only\n    //     comparison that can be made.\n    //   - For types that can be introspected, but rarely have requirements to be compared\n    //     (`ArrayBuffer`, `DataView`, etc.), the cost is avoided to prioritize the common\n    //     use-cases (may be included in a future release, if requested enough).\n    //   - For types that can be introspected but do not have an objective definition of what\n    //     equality is (`Error`, etc.), the subjective decision is to be conservative and strictly compare.\n    // In all cases, these decisions should be reevaluated based on changes to the language and\n    // common development practices.\n    return false;\n  };\n}\n\n/**\n * Create the configuration object used for building comparators.\n */\nexport function createEqualityComparatorConfig<Meta>({\n  circular,\n  createCustomConfig,\n  strict,\n}: CustomEqualCreatorOptions<Meta>): ComparatorConfig<Meta> {\n  let config = {\n    areArraysEqual: strict\n      ? areObjectsEqualStrictDefault\n      : areArraysEqualDefault,\n    areDatesEqual: areDatesEqualDefault,\n    areMapsEqual: strict\n      ? combineComparators(areMapsEqualDefault, areObjectsEqualStrictDefault)\n      : areMapsEqualDefault,\n    areObjectsEqual: strict\n      ? areObjectsEqualStrictDefault\n      : areObjectsEqualDefault,\n    arePrimitiveWrappersEqual: arePrimitiveWrappersEqualDefault,\n    areRegExpsEqual: areRegExpsEqualDefault,\n    areSetsEqual: strict\n      ? combineComparators(areSetsEqualDefault, areObjectsEqualStrictDefault)\n      : areSetsEqualDefault,\n    areTypedArraysEqual: strict\n      ? areObjectsEqualStrictDefault\n      : areTypedArraysEqual,\n  };\n\n  if (createCustomConfig) {\n    config = assign({}, config, createCustomConfig(config));\n  }\n\n  if (circular) {\n    const areArraysEqual = createIsCircular(config.areArraysEqual);\n    const areMapsEqual = createIsCircular(config.areMapsEqual);\n    const areObjectsEqual = createIsCircular(config.areObjectsEqual);\n    const areSetsEqual = createIsCircular(config.areSetsEqual);\n\n    config = assign({}, config, {\n      areArraysEqual,\n      areMapsEqual,\n      areObjectsEqual,\n      areSetsEqual,\n    });\n  }\n\n  return config;\n}\n\n/**\n * Default equality comparator pass-through, used as the standard `isEqual` creator for\n * use inside the built comparator.\n */\nexport function createInternalEqualityComparator<Meta>(\n  compare: EqualityComparator<Meta>,\n): InternalEqualityComparator<Meta> {\n  return function (\n    a: any,\n    b: any,\n    _indexOrKeyA: any,\n    _indexOrKeyB: any,\n    _parentA: any,\n    _parentB: any,\n    state: State<Meta>,\n  ) {\n    return compare(a, b, state);\n  };\n}\n\n/**\n * Create the `isEqual` function used by the consuming application.\n */\nexport function createIsEqual<Meta>({\n  circular,\n  comparator,\n  createState,\n  equals,\n  strict,\n}: CreateIsEqualOptions<Meta>) {\n  if (createState) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      const { cache = circular ? new WeakMap() : undefined, meta } =\n        createState!();\n\n      return comparator(a, b, {\n        cache,\n        equals,\n        meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  if (circular) {\n    return function isEqual<A, B>(a: A, b: B): boolean {\n      return comparator(a, b, {\n        cache: new WeakMap(),\n        equals,\n        meta: undefined as Meta,\n        strict,\n      } as State<Meta>);\n    };\n  }\n\n  const state = {\n    cache: undefined,\n    equals,\n    meta: undefined,\n    strict,\n  } as State<Meta>;\n\n  return function isEqual<A, B>(a: A, b: B): boolean {\n    return comparator(a, b, state);\n  };\n}\n","import {\n  createEqualityComparatorConfig,\n  createEqualityComparator,\n  createInternalEqualityComparator,\n  createIsEqual,\n} from './comparator';\nimport type { CustomEqualCreatorOptions } from './internalTypes';\nimport { sameValueZeroEqual } from './utils';\n\nexport { sameValueZeroEqual };\nexport * from './internalTypes';\n\n/**\n * Whether the items passed are deeply-equal in value.\n */\nexport const deepEqual = createCustomEqual();\n\n/**\n * Whether the items passed are deeply-equal in value based on strict comparison.\n */\nexport const strictDeepEqual = createCustomEqual({ strict: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references.\n */\nexport const circularDeepEqual = createCustomEqual({ circular: true });\n\n/**\n * Whether the items passed are deeply-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularDeepEqual = createCustomEqual({\n  circular: true,\n  strict: true,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value.\n */\nexport const shallowEqual = createCustomEqual({\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value based on strict comparison\n */\nexport const strictShallowEqual = createCustomEqual({\n  strict: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references.\n */\nexport const circularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n});\n\n/**\n * Whether the items passed are shallowly-equal in value, including circular references,\n * based on strict comparison.\n */\nexport const strictCircularShallowEqual = createCustomEqual({\n  circular: true,\n  createInternalComparator: () => sameValueZeroEqual,\n  strict: true,\n});\n\n/**\n * Create a custom equality comparison method.\n *\n * This can be done to create very targeted comparisons in extreme hot-path scenarios\n * where the standard methods are not performant enough, but can also be used to provide\n * support for legacy environments that do not support expected features like\n * `RegExp.prototype.flags` out of the box.\n */\nexport function createCustomEqual<Meta = undefined>(\n  options: CustomEqualCreatorOptions<Meta> = {},\n) {\n  const {\n    circular = false,\n    createInternalComparator: createCustomInternalComparator,\n    createState,\n    strict = false,\n  } = options;\n\n  const config = createEqualityComparatorConfig<Meta>(options);\n  const comparator = createEqualityComparator(config);\n  const equals = createCustomInternalComparator\n    ? createCustomInternalComparator(comparator)\n    : createInternalEqualityComparator(comparator);\n\n  return createIsEqual({ circular, comparator, createState, equals, strict });\n}\n"]},"metadata":{},"sourceType":"script"}