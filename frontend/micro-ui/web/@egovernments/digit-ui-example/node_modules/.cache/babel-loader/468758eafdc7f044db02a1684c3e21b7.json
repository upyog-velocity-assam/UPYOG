{"ast":null,"code":"import e from \"void-elements\";\nvar t = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g;\nfunction n(n) {\n  var r = {\n      type: \"tag\",\n      name: \"\",\n      voidElement: !1,\n      attrs: {},\n      children: []\n    },\n    i = n.match(/<\\/?([^\\s]+?)[/\\s>]/);\n  if (i && (r.name = i[1], (e[i[1]] || \"/\" === n.charAt(n.length - 2)) && (r.voidElement = !0), r.name.startsWith(\"!--\"))) {\n    var s = n.indexOf(\"--\\x3e\");\n    return {\n      type: \"comment\",\n      comment: -1 !== s ? n.slice(4, s) : \"\"\n    };\n  }\n  for (var a = new RegExp(t), c = null; null !== (c = a.exec(n));) if (c[0].trim()) if (c[1]) {\n    var o = c[1].trim(),\n      l = [o, \"\"];\n    o.indexOf(\"=\") > -1 && (l = o.split(\"=\")), r.attrs[l[0]] = l[1], a.lastIndex--;\n  } else c[2] && (r.attrs[c[2]] = c[3].trim().substring(1, c[3].length - 1));\n  return r;\n}\nvar r = /<[a-zA-Z0-9\\-\\!\\/](?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g,\n  i = /^\\s*$/,\n  s = Object.create(null);\nfunction a(e, t) {\n  switch (t.type) {\n    case \"text\":\n      return e + t.content;\n    case \"tag\":\n      return e += \"<\" + t.name + (t.attrs ? function (e) {\n        var t = [];\n        for (var n in e) t.push(n + '=\"' + e[n] + '\"');\n        return t.length ? \" \" + t.join(\" \") : \"\";\n      }(t.attrs) : \"\") + (t.voidElement ? \"/>\" : \">\"), t.voidElement ? e : e + t.children.reduce(a, \"\") + \"</\" + t.name + \">\";\n    case \"comment\":\n      return e + \"\\x3c!--\" + t.comment + \"--\\x3e\";\n  }\n}\nvar c = {\n  parse: function (e, t) {\n    t || (t = {}), t.components || (t.components = s);\n    var a,\n      c = [],\n      o = [],\n      l = -1,\n      m = !1;\n    if (0 !== e.indexOf(\"<\")) {\n      var u = e.indexOf(\"<\");\n      c.push({\n        type: \"text\",\n        content: -1 === u ? e : e.substring(0, u)\n      });\n    }\n    return e.replace(r, function (r, s) {\n      if (m) {\n        if (r !== \"</\" + a.name + \">\") return;\n        m = !1;\n      }\n      var u,\n        f = \"/\" !== r.charAt(1),\n        h = r.startsWith(\"\\x3c!--\"),\n        p = s + r.length,\n        d = e.charAt(p);\n      if (h) {\n        var v = n(r);\n        return l < 0 ? (c.push(v), c) : ((u = o[l]).children.push(v), c);\n      }\n      if (f && (l++, \"tag\" === (a = n(r)).type && t.components[a.name] && (a.type = \"component\", m = !0), a.voidElement || m || !d || \"<\" === d || a.children.push({\n        type: \"text\",\n        content: e.slice(p, e.indexOf(\"<\", p))\n      }), 0 === l && c.push(a), (u = o[l - 1]) && u.children.push(a), o[l] = a), (!f || a.voidElement) && (l > -1 && (a.voidElement || a.name === r.slice(2, -1)) && (l--, a = -1 === l ? c : o[l]), !m && \"<\" !== d && d)) {\n        u = -1 === l ? c : o[l].children;\n        var x = e.indexOf(\"<\", p),\n          g = e.slice(p, -1 === x ? void 0 : x);\n        i.test(g) && (g = \" \"), (x > -1 && l + u.length >= 0 || \" \" !== g) && u.push({\n          type: \"text\",\n          content: g\n        });\n      }\n    }), c;\n  },\n  stringify: function (e) {\n    return e.reduce(function (e, t) {\n      return e + a(\"\", t);\n    }, \"\");\n  }\n};\nexport default c;","map":{"version":3,"sources":["../src/parse-tag.js","../src/parse.js","../src/stringify.js","../src/index.js"],"names":["attrRE","stringify","tag","res","type","name","voidElement","attrs","children","tagMatch","match","lookup","charAt","length","startsWith","endIndex","indexOf","comment","slice","reg","RegExp","result","exec","trim","attr","arr","split","lastIndex","substring","tagRE","whitespaceRE","empty","Object","create","html","options","components","current","level","inComponent","end","push","content","replace","index","isOpen","isComment","start","nextChar","parent","parseTag","undefined","test","buff","key","join","doc","attrString","reduce","token","rootEl","parse"],"mappings":"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","sourcesContent":["import lookup from 'void-elements'\nconst attrRE = /\\s([^'\"/\\s><]+?)[\\s/>]|([^\\s=]+)=\\s?(\".*?\"|'.*?')/g\n\nexport default function stringify(tag) {\n  const res = {\n    type: 'tag',\n    name: '',\n    voidElement: false,\n    attrs: {},\n    children: [],\n  }\n\n  const tagMatch = tag.match(/<\\/?([^\\s]+?)[/\\s>]/)\n  if (tagMatch) {\n    res.name = tagMatch[1]\n    if (\n      lookup[tagMatch[1]] ||\n      tag.charAt(tag.length - 2) === '/'\n    ) {\n      res.voidElement = true\n    }\n\n    // handle comment tag\n    if (res.name.startsWith('!--')) {\n      const endIndex = tag.indexOf('-->')\n      return {\n        type: 'comment',\n        comment: endIndex !== -1 ? tag.slice(4, endIndex) : '',\n      }\n    }\n  }\n\n  const reg = new RegExp(attrRE)\n  let result = null\n  for (;;) {\n    result = reg.exec(tag)\n\n    if (result === null) {\n      break\n    }\n\n    if (!result[0].trim()) {\n      continue\n    }\n\n    if (result[1]) {\n      const attr = result[1].trim()\n      let arr = [attr, '']\n\n      if (attr.indexOf('=') > -1) {\n        arr = attr.split('=')\n      }\n\n      res.attrs[arr[0]] = arr[1]\n      reg.lastIndex--\n    } else if (result[2]) {\n      res.attrs[result[2]] = result[3].trim().substring(1, result[3].length - 1)\n    }\n  }\n\n  return res\n}\n","import parseTag from './parse-tag'\n\nconst tagRE = /<[a-zA-Z0-9\\-\\!\\/](?:\"[^\"]*\"|'[^']*'|[^'\">])*>/g\nconst whitespaceRE = /^\\s*$/\n\n// re-used obj for quick lookups of components\nconst empty = Object.create(null)\n\nexport default function parse(html, options) {\n  options || (options = {})\n  options.components || (options.components = empty)\n  const result = []\n  const arr = []\n  let current\n  let level = -1\n  let inComponent = false\n\n  // handle text at top level\n  if (html.indexOf('<') !== 0) {\n    var end = html.indexOf('<')\n    result.push({\n      type: 'text',\n      content: end === -1 ? html : html.substring(0, end),\n    })\n  }\n\n  html.replace(tagRE, function (tag, index) {\n    if (inComponent) {\n      if (tag !== '</' + current.name + '>') {\n        return\n      } else {\n        inComponent = false\n      }\n    }\n    const isOpen = tag.charAt(1) !== '/'\n    const isComment = tag.startsWith('<!--')\n    const start = index + tag.length\n    const nextChar = html.charAt(start)\n    let parent\n\n    if (isComment) {\n      const comment = parseTag(tag)\n\n      // if we're at root, push new base node\n      if (level < 0) {\n        result.push(comment)\n        return result\n      }\n      parent = arr[level]\n      parent.children.push(comment)\n      return result\n    }\n\n    if (isOpen) {\n      level++\n\n      current = parseTag(tag)\n      if (current.type === 'tag' && options.components[current.name]) {\n        current.type = 'component'\n        inComponent = true\n      }\n\n      if (\n        !current.voidElement &&\n        !inComponent &&\n        nextChar &&\n        nextChar !== '<'\n      ) {\n        current.children.push({\n          type: 'text',\n          content: html.slice(start, html.indexOf('<', start)),\n        })\n      }\n\n      // if we're at root, push new base node\n      if (level === 0) {\n        result.push(current)\n      }\n\n      parent = arr[level - 1]\n\n      if (parent) {\n        parent.children.push(current)\n      }\n\n      arr[level] = current\n    }\n\n    if (!isOpen || current.voidElement) {\n      if (\n        level > -1 &&\n        (current.voidElement || current.name === tag.slice(2, -1))\n      ) {\n        level--\n        // move current up a level to match the end tag\n        current = level === -1 ? result : arr[level]\n      }\n      if (!inComponent && nextChar !== '<' && nextChar) {\n        // trailing text node\n        // if we're at the root, push a base text node. otherwise add as\n        // a child to the current node.\n        parent = level === -1 ? result : arr[level].children\n\n        // calculate correct end of the content slice in case there's\n        // no tag after the text node.\n        const end = html.indexOf('<', start)\n        let content = html.slice(start, end === -1 ? undefined : end)\n        // if a node is nothing but whitespace, collapse it as the spec states:\n        // https://www.w3.org/TR/html4/struct/text.html#h-9.1\n        if (whitespaceRE.test(content)) {\n          content = ' '\n        }\n        // don't add whitespace-only text nodes if they would be trailing text nodes\n        // or if they would be leading whitespace-only text nodes:\n        //  * end > -1 indicates this is not a trailing text node\n        //  * leading node is when level is -1 and parent has length 0\n        if ((end > -1 && level + parent.length >= 0) || content !== ' ') {\n          parent.push({\n            type: 'text',\n            content: content,\n          })\n        }\n      }\n    }\n  })\n\n  return result\n}\n","function attrString(attrs) {\n  const buff = []\n  for (let key in attrs) {\n    buff.push(key + '=\"' + attrs[key] + '\"')\n  }\n  if (!buff.length) {\n    return ''\n  }\n  return ' ' + buff.join(' ')\n}\n\nfunction stringify(buff, doc) {\n  switch (doc.type) {\n    case 'text':\n      return buff + doc.content\n    case 'tag':\n      buff +=\n        '<' +\n        doc.name +\n        (doc.attrs ? attrString(doc.attrs) : '') +\n        (doc.voidElement ? '/>' : '>')\n      if (doc.voidElement) {\n        return buff\n      }\n      return buff + doc.children.reduce(stringify, '') + '</' + doc.name + '>'\n    case 'comment':\n      buff += '<!--' + doc.comment + '-->'\n      return buff\n  }\n}\n\nexport default function (doc) {\n  return doc.reduce(function (token, rootEl) {\n    return token + stringify('', rootEl)\n  }, '')\n}\n","import parse from './parse'\nimport stringify from './stringify'\n\nexport default {\n  parse,\n  stringify,\n}\n"]},"metadata":{},"sourceType":"module"}